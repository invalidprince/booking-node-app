<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Book a Space</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; margin: 0; padding: 20px; }
    h1 { text-align: center; color: #333; }
    /* Cards should flex gracefully on small screens.  Set a max width and
       allow them to fill available width on mobile devices. */
    .card {
      background: white;
      padding: 20px;
      margin: 0 auto 20px auto;
      width: 100%;
      max-width: 600px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .field { margin-bottom: 12px; }
    label { display: block; margin-bottom: 4px; color: #555; }
    input[type="text"], input[type="email"], input[type="date"], select {
      width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;
    }
    button { background: #007bff; color: white; padding: 10px 16px; border: none; border-radius: 4px; cursor: pointer; }
    button:hover { background: #0056b3; }
    .status { margin-top: 15px; min-height: 20px; color: #333; }
    .timepicker-dropdown select { margin-right: 4px; padding: 4px; }
    .link-bar { text-align: center; margin-bottom: 16px; }
    .link-bar a { margin: 0 8px; color: #007bff; text-decoration: none; }
    .link-bar a:hover { text-decoration: underline; }
    /* Styles for availability results */
    .yes { color: #2e7d32; font-weight: bold; }
    .no { color: #c62828; font-weight: bold; }
    /* Table styles for aggregated availability */
    table.availability-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }
    table.availability-table th,
    table.availability-table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    table.availability-table th {
      background: #fafafa;
    }
  </style>
</head>
<body>
  <h1>Book a Space</h1>
  <div class="link-bar" style="text-align: right;">
    <!-- Link to Admin portal on top right -->
    <a href="admin.html" id="adminLink">Admin Portal</a>
  </div>
  <div class="card">
    <div class="field">
      <label for="name">Full Name</label>
      <input type="text" id="name" placeholder="Your name">
    </div>
    <div class="field">
      <label for="email">Email Address</label>
      <input type="email" id="email" placeholder="you@example.com">
    </div>
    <div class="field">
      <label for="date">Date</label>
      <input type="date" id="date">
    </div>
    <div class="field">
      <label for="start-time">Start Time</label>
      <input type="text" id="start-time" readonly placeholder="Select time">
    </div>
    <div class="field">
      <label for="end-time">End Time</label>
      <input type="text" id="end-time" readonly placeholder="Select time">
    </div>
    <div class="field">
      <label for="space">Space</label>
      <select id="space"></select>
    </div>
    <button id="book-btn" type="button">Book</button>
    <div class="status" id="status"></div>
  </div>

  <!-- Email verification overlay (hidden by default) -->
  <div id="verificationOverlay" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); justify-content:center; align-items:center; z-index:1000;">
    <div class="card" style="max-width:400px; text-align:center;">
      <h2>Email Verification Required</h2>
      <p>Please enter your @fbhi.net email to verify before booking.</p>
      <input type="email" id="verifyEmail" placeholder="you@fbhi.net" style="width:100%; margin-bottom:8px;">
      <button id="verifyBtn" type="button">Send Verification Link</button>
      <div id="verifyStatus" style="margin-top:8px; color:#333;"></div>
    </div>
  </div>

  <!-- Availability section -->
  <div class="card" id="availability-section">
    <h2>Check Space Availability</h2>
    <div class="field">
      <label for="avDate">Date</label>
      <input type="date" id="avDate">
    </div>
    <div class="field">
      <label for="avSpace">Space</label>
      <select id="avSpace"></select>
    </div>
    <button id="checkBtn" type="button">Check Availability</button>
    <div id="results"></div>
  </div>

  <script>
    // Populate the list of spaces and auto-booking options
    async function populateSpaces() {
      try {
        const res = await fetch('/api/spaces');
        const spaces = await res.json();
        const select = document.getElementById('space');
        select.innerHTML = '';
        // Auto-booking options
        const autoDesk = document.createElement('option');
        autoDesk.value = 'auto-desk';
        autoDesk.textContent = 'Auto book Desk';
        select.appendChild(autoDesk);
        const autoOffice = document.createElement('option');
        autoOffice.value = 'auto-office';
        autoOffice.textContent = 'Auto book Office';
        select.appendChild(autoOffice);
        spaces.forEach(space => {
          const opt = document.createElement('option');
          opt.value = space.id;
          opt.textContent = space.name;
          select.appendChild(opt);
        });
      } catch (err) {
        console.error(err);
      }
    }

    // Convert 12h time string (e.g. "3:30 PM") to 24h format (HH:MM)
    function convertTo24h(str) {
      if (!str) return '';
      const parts = str.trim().split(' ');
      if (parts.length < 2) return str;
      const time = parts[0], period = parts[1];
      let [hour, minute] = time.split(':');
      hour = parseInt(hour, 10);
      if (period === 'PM' && hour !== 12) hour += 12;
      if (period === 'AM' && hour === 12) hour = 0;
      return `${hour.toString().padStart(2, '0')}:${minute}`;
    }

    // Create a custom time picker that appears on focus
    function createTimePicker(inputId) {
      const input = document.getElementById(inputId);
      const container = document.createElement('div');
      container.className = 'timepicker-dropdown';
      container.style.position = 'absolute';
      container.style.display = 'none';
      container.style.background = '#fff';
      container.style.border = '1px solid #ccc';
      container.style.padding = '6px';
      container.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
      container.style.zIndex = 1000;
      const hourSelect = document.createElement('select');
      for (let i = 1; i <= 12; i++) {
        const opt = document.createElement('option');
        opt.value = i < 10 ? '0' + i : '' + i;
        opt.textContent = opt.value;
        hourSelect.appendChild(opt);
      }
      const minuteSelect = document.createElement('select');
      ['00', '15', '30', '45'].forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        minuteSelect.appendChild(opt);
      });
      const periodSelect = document.createElement('select');
      ['AM', 'PM'].forEach(p => {
        const opt = document.createElement('option');
        opt.value = p;
        opt.textContent = p;
        periodSelect.appendChild(opt);
      });
      const setBtn = document.createElement('button');
      setBtn.type = 'button';
      setBtn.textContent = 'Set';
      setBtn.style.marginLeft = '8px';
      setBtn.onclick = () => {
        const value = `${hourSelect.value}:${minuteSelect.value} ${periodSelect.value}`;
        input.value = value;
        container.style.display = 'none';
      };
      container.appendChild(hourSelect);
      container.appendChild(minuteSelect);
      container.appendChild(periodSelect);
      container.appendChild(setBtn);
      document.body.appendChild(container);
      input.addEventListener('focus', () => {
        const rect = input.getBoundingClientRect();
        container.style.left = `${rect.left + window.scrollX}px`;
        container.style.top = `${rect.bottom + window.scrollY + 2}px`;
        container.style.display = 'block';
      });
      document.addEventListener('click', (e) => {
        if (e.target !== input && !container.contains(e.target)) {
          container.style.display = 'none';
        }
      });
    }

    // Submit the booking form
    async function doBook() {
      const name = document.getElementById('name').value.trim();
      const email = document.getElementById('email').value.trim();
      const date = document.getElementById('date').value;
      const startRaw = document.getElementById('start-time').value;
      const endRaw = document.getElementById('end-time').value;
      const spaceVal = document.getElementById('space').value;
      const statusEl = document.getElementById('status');
      statusEl.style.color = '#333';
      if (!name || !email || !date || !startRaw || !endRaw || !spaceVal) {
        statusEl.textContent = 'Please fill in all fields.';
        return;
      }
      // Validate email domain on client side (trim and normalise)
      const emailNormalized = email.toLowerCase().trim();
      if (!emailNormalized.endsWith('@fbhi.net')) {
        statusEl.style.color = 'red';
        statusEl.textContent = 'Email must be a @fbhi.net address.';
        return;
      }
      const startTime = convertTo24h(startRaw);
      const endTime = convertTo24h(endRaw);

      // Prevent booking before current date/time. Parse the selected
      // date and start time into a Date object (local time) and
      // compare against the current time. If the booking start is
      // earlier than now, show an error and abort.
      const bookingStart = new Date(`${date}T${startTime}:00`);
      if (bookingStart.getTime() < Date.now()) {
        statusEl.style.color = 'red';
        statusEl.textContent = 'Cannot book prior to the current date/time.';
        return;
      }
      try {
        // Clientâ€‘side verification is not enforced here; overlay ensures the first visit verification.
        if (spaceVal.startsWith('auto-')) {
          const type = spaceVal === 'auto-desk' ? 'desk' : 'office';
          const params = new URLSearchParams({ type, date, start: startTime, end: endTime, name, email });
          const res = await fetch('/api/bookings/auto?' + params.toString());
          if (res.ok) {
            const data = await res.json();
            statusEl.style.color = 'green';
            statusEl.textContent = `Success! Reserved ${data.spaceName} on ${date}.`;
          } else {
            const err = await res.json();
            statusEl.style.color = 'red';
            statusEl.textContent = err.error || 'Auto-book failed.';
          }
        } else {
          const res = await fetch('/api/bookings', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, email, spaceId: spaceVal, date, startTime, endTime, recurring: false })
          });
          if (res.ok) {
            const data = await res.json();
            statusEl.style.color = 'green';
            statusEl.textContent = `Success! Your booking ID is ${data.id}.`;
          } else {
            const err = await res.json();
            statusEl.style.color = 'red';
            statusEl.textContent = err.error || 'Booking failed.';
          }
        }
      } catch (err) {
        console.error(err);
        statusEl.style.color = 'red';
        statusEl.textContent = 'An error occurred while booking.';
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      populateSpaces();
      createTimePicker('start-time');
      createTimePicker('end-time');
      document.getElementById('book-btn').addEventListener('click', doBook);

      // Availability initialization
      populateAvailSpaces();
      document.getElementById('checkBtn').addEventListener('click', checkAvailability);

      // Show verification overlay on first visit if email not verified
      checkVerificationStatus();
      document.getElementById('verifyBtn').addEventListener('click', requestVerification);

      // If a verified email is stored, prefill the email field and prevent editing
      try {
        const verifiedFlag = localStorage.getItem('emailVerified');
        const verifiedEmail = localStorage.getItem('verifiedEmail');
        const emailInput = document.getElementById('email');
        if (verifiedFlag === 'true' && verifiedEmail) {
          emailInput.value = verifiedEmail;
          emailInput.readOnly = true;
          emailInput.style.background = '#f0f0f0';
        }
      } catch (e) {}
    });

    // Show or hide verification overlay depending on localStorage flag
    function checkVerificationStatus() {
      try {
        const verified = localStorage.getItem('emailVerified');
        if (verified === 'true') {
          document.getElementById('verificationOverlay').style.display = 'none';
        } else {
          document.getElementById('verificationOverlay').style.display = 'flex';
        }
      } catch (e) {
        document.getElementById('verificationOverlay').style.display = 'flex';
      }
    }

    // Send a verification email request
    async function requestVerification() {
      const emailInput = document.getElementById('verifyEmail');
      const statusEl = document.getElementById('verifyStatus');
      const email = emailInput.value.trim().toLowerCase();
      statusEl.style.color = '#333';
      statusEl.textContent = '';
      if (!email || !email.endsWith('@fbhi.net')) {
        statusEl.style.color = 'red';
        statusEl.textContent = 'Please enter a valid @fbhi.net email address.';
        return;
      }
      try {
        const res = await fetch('/api/request-verification', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ email })
        });
        if (res.ok) {
          statusEl.style.color = 'green';
          statusEl.textContent = 'A verification email has been sent. Please check your inbox.';
        } else {
          const err = await res.json().catch(() => ({ error: 'Failed to send verification' }));
          statusEl.style.color = 'red';
          statusEl.textContent = err.error || 'Failed to send verification.';
        }
      } catch (err) {
        statusEl.style.color = 'red';
        statusEl.textContent = 'An error occurred while sending the verification email.';
      }
    }

    // Populate spaces for availability check (without auto options)
    async function populateAvailSpaces() {
      try {
        const res = await fetch('/api/spaces');
        const data = await res.json();
        const sel = document.getElementById('avSpace');
        sel.innerHTML = '';
        data.forEach(space => {
          const opt = document.createElement('option');
          opt.value = space.id;
          opt.textContent = space.name;
          sel.appendChild(opt);
        });
      } catch (err) {
        console.error(err);
      }
    }

    // Generate time slots in 30 minute increments for a full day (00:00 - 24:00).
    // Each slot is an object with a start and end time in HH:MM format. We do
    // this clientâ€‘side and later group contiguous slots with identical
    // availability into longer segments for display.
    function generateTimeSlots() {
      const slots = [];
      const pad = n => String(n).padStart(2, '0');
      for (let hour = 0; hour < 24; hour++) {
        const h1 = pad(hour);
        const h2 = pad((hour + 1) % 24);
        // two 30â€‘minute chunks per hour
        slots.push({ start: `${h1}:00`, end: `${h1}:30` });
        slots.push({ start: `${h1}:30`, end: `${h2}:00` });
      }
      return slots;
    }

    // Convert 24h time to 12h AM/PM for display
    function to12Hour(time) {
      if (typeof time !== 'string' || !time.includes(':')) return time;
      const [hStr, m] = time.split(':');
      let h = parseInt(hStr, 10);
      if (isNaN(h)) return time;
      const ampm = h >= 12 ? 'PM' : 'AM';
      h = h % 12;
      if (h === 0) h = 12;
      return `${h}:${m} ${ampm}`;
    }

    // Check space availability and render results
    async function checkAvailability() {
      const date = document.getElementById('avDate').value;
      const spaceId = document.getElementById('avSpace').value;
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '';
      if (!date || !spaceId) {
        resultsDiv.textContent = 'Please select a date and space.';
        return;
      }
      // Fetch spaces to determine the selected space type
      let spacesList = [];
      try {
        const resSpaces = await fetch('/api/spaces');
        spacesList = await resSpaces.json();
      } catch (err) {
        console.error(err);
      }
      const selected = spacesList.find(s => s.id === spaceId);
      if (!selected) {
        resultsDiv.textContent = 'Invalid space.';
        return;
      }
      const slots = generateTimeSlots();
      // Query availability for each slot in parallel
      const promises = slots.map(async ({ start, end }) => {
        const params = new URLSearchParams({ date, start, end });
        params.append('type', selected.type);
        const res = await fetch('/api/availability?' + params.toString());
        const avail = await res.json();
        const isAvail = avail.some(s => s.id === spaceId);
        return { start, end, available: isAvail };
      });
      const results = await Promise.all(promises);
      // Group contiguous slots into availability segments.  This reduces the
      // number of rows and makes it clear when the space is free or
      // unavailable.  We rely on the slots being ordered chronologically.
      const segments = [];
      let current = null;
      results.forEach(r => {
        if (!current) {
          current = { start: r.start, end: r.end, available: r.available };
        } else if (r.available === current.available) {
          // Extend the current segment
          current.end = r.end;
        } else {
          segments.push(current);
          current = { start: r.start, end: r.end, available: r.available };
        }
      });
      if (current) segments.push(current);
      // Build table output for aggregated segments
      const table = document.createElement('table');
      table.className = 'availability-table';
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th>Time Range</th><th>Status</th></tr>';
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      segments.forEach(seg => {
        const tr = document.createElement('tr');
        const rangeLabel = `${to12Hour(seg.start)} - ${to12Hour(seg.end)}`;
        const statusLabel = seg.available ? 'Available' : 'Unavailable';
        const statusClass = seg.available ? 'yes' : 'no';
        tr.innerHTML = `<td>${rangeLabel}</td><td class="${statusClass}">${statusLabel}</td>`;
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      resultsDiv.appendChild(table);
    }
  </script>
</body>
</html>